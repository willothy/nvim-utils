/* automatically generated by rust-bindgen 0.64.0 */

pub type LuaCFunction = unsafe extern "C" fn(L: *mut LuaState) -> ::std::os::raw::c_int;
pub type LuaNumber = f64;
pub type LuaInteger = isize;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LuaState {
    _unused: [u8; 0],
}

// Indices
pub const LUA_REGISTRYINDEX: i32 = -10000;
pub const LUA_ENVIRONINDEX: i32 = -10001;
pub const LUA_GLOBALSINDEX: i32 = -10002;

// Status
pub const LUA_OK: u32 = 0;
pub const LUA_YIELD: u32 = 1;
pub const LUA_ERRRUN: u32 = 2;
pub const LUA_ERRSYNTAX: u32 = 3;
pub const LUA_ERRMEM: u32 = 4;
pub const LUA_ERRERR: u32 = 5;

// Types
pub const LUA_TNONE: i32 = -1;
pub const LUA_TNIL: u32 = 0;
pub const LUA_TBOOLEAN: u32 = 1;
pub const LUA_TLIGHTUSERDATA: u32 = 2;
pub const LUA_TNUMBER: u32 = 3;
pub const LUA_TSTRING: u32 = 4;
pub const LUA_TTABLE: u32 = 5;
pub const LUA_TFUNCTION: u32 = 6;
pub const LUA_TUSERDATA: u32 = 7;
pub const LUA_TTHREAD: u32 = 8;

extern "C" {
    pub fn lua_newstate(f: LuaAlloc, ud: *mut ::std::os::raw::c_void) -> *mut LuaState;

    pub fn lua_close(L: *mut LuaState);

    pub fn lua_newthread(L: *mut LuaState) -> *mut LuaState;

    pub fn lua_atpanic(L: *mut LuaState, panicf: LuaCFunction) -> LuaCFunction;

    pub fn lua_gettop(L: *mut LuaState) -> ::std::os::raw::c_int;

    pub fn lua_settop(L: *mut LuaState, idx: ::std::os::raw::c_int);

    pub fn lua_pushvalue(L: *mut LuaState, idx: ::std::os::raw::c_int);

    pub fn lua_remove(L: *mut LuaState, idx: ::std::os::raw::c_int);

    pub fn lua_insert(L: *mut LuaState, idx: ::std::os::raw::c_int);

    pub fn lua_replace(L: *mut LuaState, idx: ::std::os::raw::c_int);

    pub fn lua_checkstack(L: *mut LuaState, sz: ::std::os::raw::c_int) -> ::std::os::raw::c_int;

    pub fn lua_xmove(from: *mut LuaState, to: *mut LuaState, n: ::std::os::raw::c_int);

    pub fn lua_isnumber(L: *mut LuaState, idx: ::std::os::raw::c_int) -> ::std::os::raw::c_int;

    pub fn lua_isstring(L: *mut LuaState, idx: ::std::os::raw::c_int) -> ::std::os::raw::c_int;

    pub fn lua_iscfunction(L: *mut LuaState, idx: ::std::os::raw::c_int) -> ::std::os::raw::c_int;

    pub fn lua_isuserdata(L: *mut LuaState, idx: ::std::os::raw::c_int) -> ::std::os::raw::c_int;

    pub fn lua_type(L: *mut LuaState, idx: ::std::os::raw::c_int) -> ::std::os::raw::c_int;

    pub fn lua_typename(
        L: *mut LuaState,
        tp: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;

    pub fn lua_equal(
        L: *mut LuaState,
        idx1: ::std::os::raw::c_int,
        idx2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;

    pub fn lua_rawequal(
        L: *mut LuaState,
        idx1: ::std::os::raw::c_int,
        idx2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;

    pub fn lua_lessthan(
        L: *mut LuaState,
        idx1: ::std::os::raw::c_int,
        idx2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;

    pub fn lua_tonumber(L: *mut LuaState, idx: ::std::os::raw::c_int) -> LuaNumber;

    pub fn lua_tointeger(L: *mut LuaState, idx: ::std::os::raw::c_int) -> LuaInteger;

    pub fn lua_toboolean(L: *mut LuaState, idx: ::std::os::raw::c_int) -> ::std::os::raw::c_int;

    pub fn lua_tolstring(
        L: *mut LuaState,
        idx: ::std::os::raw::c_int,
        len: *mut usize,
    ) -> *const ::std::os::raw::c_char;

    pub fn lua_objlen(L: *mut LuaState, idx: ::std::os::raw::c_int) -> usize;

    pub fn lua_tocfunction(L: *mut LuaState, idx: ::std::os::raw::c_int) -> LuaCFunction;

    pub fn lua_touserdata(
        L: *mut LuaState,
        idx: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;

    pub fn lua_tothread(L: *mut LuaState, idx: ::std::os::raw::c_int) -> *mut LuaState;

    pub fn lua_topointer(
        L: *mut LuaState,
        idx: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_void;

    pub fn lua_pushnil(L: *mut LuaState);

    pub fn lua_pushnumber(L: *mut LuaState, n: LuaNumber);

    pub fn lua_pushinteger(L: *mut LuaState, n: LuaInteger);

    pub fn lua_pushlstring(L: *mut LuaState, s: *const ::std::os::raw::c_char, l: usize);

    pub fn lua_pushstring(L: *mut LuaState, s: *const ::std::os::raw::c_char);

    pub fn lua_pushvfstring(
        L: *mut LuaState,
        fmt: *const ::std::os::raw::c_char,
        argp: *mut __va_list_tag,
    ) -> *const ::std::os::raw::c_char;

    pub fn lua_pushfstring(
        L: *mut LuaState,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> *const ::std::os::raw::c_char;

    pub fn lua_pushcclosure(L: *mut LuaState, fn_: LuaCFunction, n: ::std::os::raw::c_int);

    pub fn lua_pushboolean(L: *mut LuaState, b: ::std::os::raw::c_int);

    pub fn lua_pushlightuserdata(L: *mut LuaState, p: *mut ::std::os::raw::c_void);

    pub fn lua_pushthread(L: *mut LuaState) -> ::std::os::raw::c_int;

    pub fn lua_gettable(L: *mut LuaState, idx: ::std::os::raw::c_int);

    pub fn lua_getfield(
        L: *mut LuaState,
        idx: ::std::os::raw::c_int,
        k: *const ::std::os::raw::c_char,
    );

    pub fn lua_rawget(L: *mut LuaState, idx: ::std::os::raw::c_int);

    pub fn lua_rawgeti(L: *mut LuaState, idx: ::std::os::raw::c_int, n: ::std::os::raw::c_int);

    pub fn lua_createtable(
        L: *mut LuaState,
        narr: ::std::os::raw::c_int,
        nrec: ::std::os::raw::c_int,
    );

    pub fn lua_newuserdata(L: *mut LuaState, sz: usize) -> *mut ::std::os::raw::c_void;

    pub fn lua_getmetatable(
        L: *mut LuaState,
        objindex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;

    pub fn lua_getfenv(L: *mut LuaState, idx: ::std::os::raw::c_int);

    pub fn lua_settable(L: *mut LuaState, idx: ::std::os::raw::c_int);

    pub fn lua_setfield(
        L: *mut LuaState,
        idx: ::std::os::raw::c_int,
        k: *const ::std::os::raw::c_char,
    );

    pub fn lua_rawset(L: *mut LuaState, idx: ::std::os::raw::c_int);

    pub fn lua_rawseti(L: *mut LuaState, idx: ::std::os::raw::c_int, n: ::std::os::raw::c_int);

    pub fn lua_setmetatable(
        L: *mut LuaState,
        objindex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;

    pub fn lua_setfenv(L: *mut LuaState, idx: ::std::os::raw::c_int) -> ::std::os::raw::c_int;

    pub fn lua_call(
        L: *mut LuaState,
        nargs: ::std::os::raw::c_int,
        nresults: ::std::os::raw::c_int,
    );

    pub fn lua_pcall(
        L: *mut LuaState,
        nargs: ::std::os::raw::c_int,
        nresults: ::std::os::raw::c_int,
        errfunc: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;

    pub fn lua_cpcall(
        L: *mut LuaState,
        func: LuaCFunction,
        ud: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;

    pub fn lua_load(
        L: *mut LuaState,
        reader: LuaReader,
        dt: *mut ::std::os::raw::c_void,
        chunkname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;

    pub fn lua_dump(
        L: *mut LuaState,
        writer: LuaWriter,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;

    pub fn lua_yield(L: *mut LuaState, nresults: ::std::os::raw::c_int) -> ::std::os::raw::c_int;

    pub fn lua_resume(L: *mut LuaState, narg: ::std::os::raw::c_int) -> ::std::os::raw::c_int;

    pub fn lua_status(L: *mut LuaState) -> ::std::os::raw::c_int;

    pub fn lua_gc(
        L: *mut LuaState,
        what: ::std::os::raw::c_int,
        data: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;

    pub fn lua_error(L: *mut LuaState) -> !;

    pub fn lua_next(L: *mut LuaState, idx: ::std::os::raw::c_int) -> ::std::os::raw::c_int;

    pub fn lua_concat(L: *mut LuaState, n: ::std::os::raw::c_int);

    pub fn lua_getallocf(L: *mut LuaState, ud: *mut *mut ::std::os::raw::c_void) -> LuaAlloc;

    pub fn lua_setallocf(L: *mut LuaState, f: LuaAlloc, ud: *mut ::std::os::raw::c_void);

    pub fn lua_setlevel(from: *mut LuaState, to: *mut LuaState);

    pub fn lua_getstack(
        L: *mut LuaState,
        level: ::std::os::raw::c_int,
        ar: *mut LuaDebug,
    ) -> ::std::os::raw::c_int;

    pub fn lua_getinfo(
        L: *mut LuaState,
        what: *const ::std::os::raw::c_char,
        ar: *mut LuaDebug,
    ) -> ::std::os::raw::c_int;

    pub fn lua_getlocal(
        L: *mut LuaState,
        ar: *const LuaDebug,
        n: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;

    pub fn lua_setlocal(
        L: *mut LuaState,
        ar: *const LuaDebug,
        n: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;

    pub fn lua_getupvalue(
        L: *mut LuaState,
        funcindex: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;

    pub fn lua_setupvalue(
        L: *mut LuaState,
        funcindex: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;

    pub fn lua_sethook(
        L: *mut LuaState,
        func: LuaHook,
        mask: ::std::os::raw::c_int,
        count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;

    pub fn lua_gethook(L: *mut LuaState) -> LuaHook;

    pub fn lua_gethookmask(L: *mut LuaState) -> ::std::os::raw::c_int;

    pub fn lua_gethookcount(L: *mut LuaState) -> ::std::os::raw::c_int;

    pub fn lua_upvalueid(
        L: *mut LuaState,
        idx: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;

    pub fn lua_upvaluejoin(
        L: *mut LuaState,
        idx1: ::std::os::raw::c_int,
        n1: ::std::os::raw::c_int,
        idx2: ::std::os::raw::c_int,
        n2: ::std::os::raw::c_int,
    );

    pub fn lua_loadx(
        L: *mut LuaState,
        reader: LuaReader,
        dt: *mut ::std::os::raw::c_void,
        chunkname: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;

    pub fn lua_version(L: *mut LuaState) -> *const LuaNumber;

    pub fn lua_copy(L: *mut LuaState, fromidx: ::std::os::raw::c_int, toidx: ::std::os::raw::c_int);

    pub fn lua_tonumberx(
        L: *mut LuaState,
        idx: ::std::os::raw::c_int,
        isnum: *mut ::std::os::raw::c_int,
    ) -> LuaNumber;

    pub fn lua_tointegerx(
        L: *mut LuaState,
        idx: ::std::os::raw::c_int,
        isnum: *mut ::std::os::raw::c_int,
    ) -> LuaInteger;

    pub fn lua_isyieldable(L: *mut LuaState) -> ::std::os::raw::c_int;
}

// Misc stuff
pub type va_list = [__va_list_tag; 1usize];
pub type wchar_t = ::std::os::raw::c_int;

pub type LuaHook = ::std::option::Option<unsafe extern "C" fn(L: *mut LuaState, ar: *mut LuaDebug)>;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LuaDebug {
    pub event: ::std::os::raw::c_int,
    pub name: *const ::std::os::raw::c_char,
    pub namewhat: *const ::std::os::raw::c_char,
    pub what: *const ::std::os::raw::c_char,
    pub source: *const ::std::os::raw::c_char,
    pub currentline: ::std::os::raw::c_int,
    pub nups: ::std::os::raw::c_int,
    pub linedefined: ::std::os::raw::c_int,
    pub lastlinedefined: ::std::os::raw::c_int,
    pub short_src: [::std::os::raw::c_char; 60usize],
    pub i_ci: ::std::os::raw::c_int,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}

#[allow(unused)]
pub type LuaReader = ::std::option::Option<
    unsafe extern "C" fn(
        L: *mut LuaState,
        ud: *mut ::std::os::raw::c_void,
        sz: *mut usize,
    ) -> *const ::std::os::raw::c_char,
>;

#[allow(unused)]
pub type LuaWriter = ::std::option::Option<
    unsafe extern "C" fn(
        L: *mut LuaState,
        p: *const ::std::os::raw::c_void,
        sz: usize,
        ud: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[allow(unused)]
pub type LuaAlloc = ::std::option::Option<
    unsafe extern "C" fn(
        ud: *mut ::std::os::raw::c_void,
        ptr: *mut ::std::os::raw::c_void,
        osize: usize,
        nsize: usize,
    ) -> *mut ::std::os::raw::c_void,
>;

// Things that were generated but probably won't be used
#[allow(unused)]
pub const LUA_MULTRET: i32 = -1;
#[allow(unused)]
pub const LUA_MINSTACK: u32 = 20;
#[allow(unused)]
pub const LUA_GCSTOP: u32 = 0;
#[allow(unused)]
pub const LUA_GCRESTART: u32 = 1;
#[allow(unused)]
pub const LUA_GCCOLLECT: u32 = 2;
#[allow(unused)]
pub const LUA_GCCOUNT: u32 = 3;
#[allow(unused)]
pub const LUA_GCCOUNTB: u32 = 4;
#[allow(unused)]
pub const LUA_GCSTEP: u32 = 5;
#[allow(unused)]
pub const LUA_GCSETPAUSE: u32 = 6;
#[allow(unused)]
pub const LUA_GCSETSTEPMUL: u32 = 7;
#[allow(unused)]
pub const LUA_GCISRUNNING: u32 = 9;
#[allow(unused)]
pub const LUA_HOOKCALL: u32 = 0;
#[allow(unused)]
pub const LUA_HOOKRET: u32 = 1;
#[allow(unused)]
pub const LUA_HOOKLINE: u32 = 2;
#[allow(unused)]
pub const LUA_HOOKCOUNT: u32 = 3;
#[allow(unused)]
pub const LUA_HOOKTAILRET: u32 = 4;
#[allow(unused)]
pub const LUA_MASKCALL: u32 = 1;
#[allow(unused)]
pub const LUA_MASKRET: u32 = 2;
#[allow(unused)]
pub const LUA_MASKLINE: u32 = 4;
#[allow(unused)]
pub const LUA_MASKCOUNT: u32 = 8;
